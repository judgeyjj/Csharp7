<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta name="description" content="1、JUC 简介&#xA;2、线程和进程&#xA;3、并非与并行&#xA;4、线程的状态&#xA;5、wait/sleep的区别&#xA;6、Lock 锁（重点）&#xA;1、Lock锁&#xA;2、公平非公平：&#xA;3、ReentrantLock 构造器&#xA;4" />
    <meta property="og:description" content="1、JUC 简介&#xA;2、线程和进程&#xA;3、并非与并行&#xA;4、线程的状态&#xA;5、wait/sleep的区别&#xA;6、Lock 锁（重点）&#xA;1、Lock锁&#xA;2、公平非公平：&#xA;3、ReentrantLock 构造器&#xA;4" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>多线程JUC并发篇常见面试详解 - 诗风雅韵 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=LdAfPG3EWG4o7Q_XIVJY6Bcod1YpBGSGJykht0T_GZw" />
    <link id="MainCss" rel="stylesheet" href="/skins/codinglife/bundle-codinglife.min.css?v=7g5gOKcn7oN77JERPfnHYGtKZZ_9q-gZn4Sp6JkXL2w" />
    <link id="highlighter-theme-agate" type="text/css" rel="stylesheet" href="/css/hljs/agate.css?v=kp6wpFoGWDWLARjInqKMjQOa80CoSWr0RGbhXohAh2c" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/codinglife/bundle-codinglife-mobile.min.css?v=qHpes9Ca8ImIRFkdtZRqyMOEED5ihHCnvYUfc-vbsbw" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/zbqblogs/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/zbqblogs/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/zbqblogs/wlwmanifest.xml" />
    <script>
        var currentBlogId = 744735;
        var currentBlogApp = 'zbqblogs';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'CodingLife';
        var visitorUserId = '';
        var hasCustomScript = false;
        try {
            if (hasCustomScript && document.referrer && document.referrer.indexOf('baidu.com') >= 0) {
                Object.defineProperty(document, 'referrer', { value: '' });
                Object.defineProperty(Document.prototype, 'referrer', { get: function(){ return ''; } });
            }
        } catch(error) { }
        window.codeHighlightEngine = 1;
        window.enableCodeLineNumber = true;
        window.codeHighlightTheme = 'agate';
    </script>
        <script>
            var currentPostDateAdded = '2022-04-16 21:50';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=KyayiYRvpSgg7du5WKccH8LB1LMuZAKgC9DVqUljgvA"></script>
    
    
    
</head>
<body class="skin-codinglife has-navbar">
    <a name="top"></a>
        <div id="bannerbar" class="bannerbar-mobile formobile">
            <a href="https://www.heapdump.cn/training/detail/4?source=bky" onclick="countCreativeClicks('M2-HeapDump')" rel="nofollow">
                <img src="https://img2022.cnblogs.com/blog/35695/202204/35695-20220407182236380-944894887.jpg" alt="" onload="countCreativeImpressions('M2-HeapDump')" />
            </a>
        </div>
    <div id="top_nav" class="navbar forpc">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding">
                    <a href="https://www.cnblogs.com/" title="开发者的网上家园" role="banner">
                        <img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" />
                    </a>
                </li>
                <li><a href="/" onclick="countClicks('skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/huawei" onclick="countClicks('nav', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get" role="search">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="search" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <a id="navbar_lite_mode_indicator" data-current-page="blog" style="display: none" href="javascript:void(0)" alt="简洁模式" title="简洁模式启用，您在访问他人博客时会使用简洁款皮肤展示">
                        <img class="navbar-icon" src="/images/aggsite/lite-mode-on.svg" alt="简洁模式" />
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    
    <!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/zbqblogs/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/zbqblogs/">zbqblogs</a>
</h1>
<h2></h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/zbqblogs/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E8%AF%97%E9%A3%8E%E9%9B%85%E9%9F%B5">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/zbqblogs/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zbqblogs/p/16154384.html">
    <span role="heading" aria-level="2">多线程JUC并发篇常见面试详解</span>
    
</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        1、JUC 简介
2、线程和进程
3、并非与并行
4、线程的状态
5、wait/sleep的区别
6、Lock 锁（重点）
1、Lock锁
2、公平非公平：
3、ReentrantLock 构造器
4、Lock 锁实现步骤：
7、synchronized 和 lock 锁的区别
8、生产者和消费者问题（通信问题）
1、Synchronized 版本
2、JUC 版本
9、八个有关锁的问题
关于锁的八个问题
10、集合类的安全问题
1、List 不安全
2、Set 不安全
。。。。。。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>@</p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1juc-简介" rel="noopener">1、JUC 简介</a><ul><li><a href="#2线程和进程" rel="noopener">2、线程和进程</a></li></ul></li><li><a href="#3并非与并行" rel="noopener">3、并非与并行</a></li><li><a href="#4线程的状态" rel="noopener">4、线程的状态</a></li><li><a href="#5waitsleep的区别" rel="noopener">5、wait/sleep的区别</a></li><li><a href="#6lock-锁重点" rel="noopener">6、Lock 锁（重点）</a><ul><li><a href="#1lock锁" rel="noopener">1、Lock锁</a></li><li><a href="#2公平非公平" rel="noopener">2、公平非公平：</a></li><li><a href="#3reentrantlock-构造器" rel="noopener">3、ReentrantLock 构造器</a></li><li><a href="#4lock-锁实现步骤" rel="noopener">4、Lock 锁实现步骤：</a></li></ul></li><li><a href="#7synchronized-和-lock-锁的区别" rel="noopener">7、synchronized 和 lock 锁的区别</a></li><li><a href="#8生产者和消费者问题通信问题" rel="noopener">8、生产者和消费者问题（通信问题）</a><ul><li><a href="#1synchronized-版本" rel="noopener">1、Synchronized 版本</a></li><li><a href="#2juc-版本" rel="noopener"><strong>2、JUC 版本</strong></a></li></ul></li><li><a href="#9八个有关锁的问题" rel="noopener">9、八个有关锁的问题</a><ul><li><ul><li><a href="#关于锁的八个问题" rel="noopener"><strong>关于锁的八个问题</strong></a></li></ul></li><li><a href="#问题1两个同步方法先执行发短信还是打电话" rel="noopener"><strong>问题1：两个同步方法，先执行发短信还是打电话？</strong></a></li><li><a href="#问题2如果发短信延迟2秒谁先执行" rel="noopener"><strong>问题2：如果发短信延迟2秒，谁先执行</strong></a></li><li><a href="#问题3-加上一个没有锁的普通方法谁先执行" rel="noopener"><strong>问题3 加上一个没有锁的普通方法，谁先执行</strong></a></li><li><a href="#问题4两个对象一个调用发短信一个调用打电话谁先执行" rel="noopener"><strong>问题4：两个对象，一个调用发短信，一个调用打电话，谁先执行</strong></a></li><li><a href="#问题5原来的两个同步方法变为静态同步方法一个对象调用谁先执行" rel="noopener"><strong>问题5：原来的两个同步方法，变为静态同步方法，一个对象调用，谁先执行</strong></a></li><li><a href="#问题6创建两个实例调用两个静态同步方法谁先执行" rel="noopener"><strong>问题6：创建两个实例，调用两个静态同步方法，谁先执行</strong></a></li><li><a href="#问题7一个静态同步方法一个同步方法一个对象调用谁先执行" rel="noopener"><strong>问题7：一个静态同步方法、一个同步方法、一个对象调用，谁先执行</strong></a></li><li><a href="#问题8两个对象一个调用静态同步方法一个调用普通同步方法谁先执行" rel="noopener"><strong>问题8：两个对象，一个调用静态同步方法，一个调用普通同步方法，谁先执行</strong></a></li><li><a href="#小结" rel="noopener"><strong>小结</strong></a></li></ul></li><li><a href="#10集合类的安全问题" rel="noopener">10、集合类的安全问题</a><ul><li><a href="#1list-不安全" rel="noopener"><strong>1、List 不安全</strong></a></li><li><a href="#2set-不安全" rel="noopener"><strong>2、Set 不安全</strong></a></li></ul></li><li><a href="#11callable简单" rel="noopener">11、Callable（简单）</a></li><li><a href="#12juc-常用辅助类" rel="noopener">12、JUC 常用辅助类</a><ul><li><a href="#1countdownlatch" rel="noopener">1、CountDownLatch</a></li><li><a href="#2cyclickbarrier" rel="noopener">2、CyclickBarrier</a></li><li><a href="#3semaphore" rel="noopener">3、Semaphore</a></li></ul></li><li><a href="#13readwritelock-读写锁" rel="noopener">13、ReadWriteLock 读写锁</a></li><li><a href="#14阻塞队列" rel="noopener">14、阻塞队列</a><ul><li><a href="#1blockqueue" rel="noopener">1、Blockqueue</a></li><li><a href="#2synchronizedqueue" rel="noopener">2、SynchronizedQueue</a></li></ul></li><li><a href="#15线程池重点" rel="noopener">15、线程池（重点）</a><ul><li><a href="#1线程池三大方法" rel="noopener">1、线程池：三大方法</a></li><li><a href="#2线程池七大参数" rel="noopener">2、线程池：七大参数</a><ul><li><a href="#3四大拒绝策瑜" rel="noopener">3、四大拒绝策瑜：</a></li></ul></li></ul></li><li><a href="#16为什么要使用线程池" rel="noopener">16、为什么要使用线程池？</a></li><li><a href="#17线程池线程复用的原理是什么" rel="noopener">17、线程池线程复用的原理是什么？</a></li><li><a href="#18aqs的理解" rel="noopener">18、AQS的理解</a><ul><li><ul><li><ul><li><a href="#1reentrantlock和aqs的关系" rel="noopener">1、ReentrantLock和AQS的关系</a></li><li><a href="#2reentrantlock加锁和释放锁的底层原理" rel="noopener">2、ReentrantLock加锁和释放锁的底层原理</a></li></ul></li></ul></li></ul></li><li><a href="#19线程创建的三种方式" rel="noopener">19、线程创建的三种方式</a></li><li><a href="#20为什么启动start就调用run方法" rel="noopener">20、为什么启动start(),就调用run方法</a></li><li><a href="#21线程的生命周期" rel="noopener">21、线程的生命周期</a></li><li><a href="#21线程安全" rel="noopener">21、线程安全：</a><ul><li><ul><li><ul><li><a href="#线程安全解决问题方案" rel="noopener">线程安全解决问题方案：</a></li></ul></li></ul></li><li><a href="#1互斥阻塞同步也就是加锁sychronized和reenrtrantlock加锁优缺点" rel="noopener">1、互斥阻塞同步：也就是加锁sychronized和ReenrtrantLock,加锁优缺点？</a></li></ul></li><li><a href="#22线程同步机制" rel="noopener">22、线程同步机制</a></li><li><a href="#23run方法和sart方法有什么区别" rel="noopener">23、run()方法和sart（）方法有什么区别</a></li><li><a href="#24线程是否可以被重复启动" rel="noopener">24、线程是否可以被重复启动</a></li><li><a href="#25volatile" rel="noopener">25、volatile</a></li><li><a href="#26java多线程之间的三种通信方式" rel="noopener">26、java多线程之间的三种通信方式</a><ul><li><a href="#1synchronized来保证线程安全" rel="noopener">1、synchronized来保证线程安全</a></li><li><a href="#2通过lock" rel="noopener">2、通过Lock（）</a></li><li><a href="#3blockingqueue" rel="noopener">3、BlockingQueue</a></li></ul></li><li><a href="#27说一说synchronized的底层实现原理" rel="noopener">27、说一说synchronized的底层实现原理</a></li><li><a href="#28cas" rel="noopener">28、CAS</a><ul><li><a href="#1概念" rel="noopener">1、概念</a></li><li><a href="#2cas可能产生aba问题" rel="noopener">2、CAS可能产生ABA问题：</a></li></ul></li><li><a href="#29锁升级初步" rel="noopener">29、锁升级初步</a><ul><li><a href="#1偏向锁" rel="noopener">1、偏向锁：</a></li><li><a href="#2轻量级锁" rel="noopener">2、轻量级锁</a></li><li><a href="#3锁重入锁" rel="noopener">3、锁重入锁</a></li><li><a href="#4自旋锁什么时候升级为重量级锁" rel="noopener">4、自旋锁什么时候升级为重量级锁</a></li><li><a href="#5为什么有自旋锁还需要重量级锁" rel="noopener">5、为什么有自旋锁还需要重量级锁</a></li><li><a href="#6偏向锁是否一定比自旋锁效率高" rel="noopener">6、偏向锁是否一定比自旋锁效率高</a></li></ul></li><li><a href="#30threadlocal机制" rel="noopener">30、ThreadLocal机制</a></li><li><a href="#31threadlocal机制的内存泄露" rel="noopener">31、ThreadLocal机制的内存泄露</a><ul><li><ul><li><ul><li><ul><li><a href="#留言" rel="noopener">留言：</a></li></ul></li></ul></li></ul></li></ul></li></ul></div><p></p>
<p>多线程JUC并发篇</p>
<h1 id="1juc-简介">1、JUC 简介</h1>
<p>什么是 JUC ？</p>
<ul>
<li>
<p>JUC 就是 java.util.concurrent 下面的类包，专门用于多线程的开发<br>
<img src="https://img-blog.csdnimg.cn/1deb4498c78746f19fd9c107a9b56648.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><br>
<strong>为什么使用 JUC ?</strong></p>
</li>
<li>
<blockquote>
<p>以往我们所学，普通的线程代码，都是用的thread或者runnable接口</p>
</blockquote>
</li>
<li>
<blockquote>
<p>但是相比于callable来说，thread没有返回值，且效率没有callable高</p>
</blockquote>
</li>
</ul>
<h2 id="2线程和进程">2、线程和进程</h2>
<ul>
<li>
<blockquote>
<p>进程就是一个应用程序</p>
</blockquote>
</li>
<li>
<blockquote>
<p>线程是进程中的一个实体，线程本身是不会独立存在的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位。</p>
</blockquote>
<blockquote>
<p>线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p>
</blockquote>
<blockquote>
<p>​                操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用CPU 运行的是线程， 所以也说线程是CPU 分配的基本单位。</p>
</blockquote>
<blockquote>
<p>​                java默认有几个线程? 两个 main线程 gc线程</p>
</blockquote>
<blockquote>
<p>​                Java 中，使用 Thread、Runnable、Callable 开启线程。</p>
</blockquote>
<blockquote>
<p>​                Java 没有权限开启线程 、Thread.start() 方法调用了一个 native 方法                         start0()，它调用了底层 C++ 代码。</p>
</blockquote>
<h1 id="3并非与并行">3、并非与并行</h1>
<p>并发多线程操作同一个资源,交替执行</p>
<ul>
<li>CPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替</li>
</ul>
<p>并行(多个人一起行走, 同时进行)</p>
<ul>
<li>CPU多核,多个线程同时进行 ; 使用线程池操作</li>
</ul>
<h1 id="4线程的状态">4、线程的状态</h1>
<ul>
<li>
<p>新建</p>
</li>
<li>
<p>就绪</p>
</li>
<li>
<p>阻塞</p>
</li>
<li>
<p>运行</p>
</li>
<li>
<p>死亡</p>
</li>
</ul>
<h1 id="5waitsleep的区别">5、wait/sleep的区别</h1>
<ul>
<li>
<blockquote>
<p>来自不同的类：wait来自object类, sleep来自线程类</p>
</blockquote>
</li>
<li>
<blockquote>
<p>关于锁的释放：wait会释放锁, sleep不会释放锁</p>
</blockquote>
</li>
<li>
<blockquote>
<p>使用范围不同：wait必须在同步代码块中，sleep可以在任何地方睡</p>
</blockquote>
</li>
<li>
<blockquote>
<p>是否需要捕获异常：wait不需要捕获异常，sleep需要捕获异常</p>
</blockquote>
</li>
</ul>
<h1 id="6lock-锁重点">6、Lock 锁（重点）</h1>
<p><strong>Synchronized 传统的锁</strong></p>
<p>之前我们所学的使用线程的传统思路是：</p>
<ul>
<li>
<p>单独创建一个线程类，继承Thread或者实现Runnable</p>
</li>
<li>
<p>在这个线程类中，重写run方法，同时添加相应的业务逻辑</p>
</li>
<li>
<p>在主线程所在方法中new上面的线程对象，调用start方法启动</p>
</li>
</ul>
<h2 id="1lock锁">1、Lock锁</h2>
<p><img src="https://img-blog.csdnimg.cn/e48a1dcbfe9a4a67aeb1716563b60e9c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aFbI65Pz-1650013582522)(https://pizximfzuc.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg2NDU1MDkyYTk1YWVlZDJjMzM3M2QxODNlMWM4NWRfeUZORjNjcWtmd3ZrR1FmWEZ2MkVWdjZMWGtHenpsM3JfVG9rZW46Ym94Y25qVzdjWERnR2owZVlMRXU4S3pTT1VjXzE2NTAwMTM0OTI6MTY1MDAxNzA5Ml9WNA)]" loading="lazy"><br>
可以看到，</p>
<p><code>Lock</code>是一个接口，有三个实现类，现在我们使用</p>
<p><code>ReentrantLock</code> 就够用了</p>
<p>查看</p>
<p><code>ReentrantLock</code> 源码，构造器</p>
<h2 id="2公平非公平">2、公平非公平：</h2>
<ul>
<li>
<p>公平锁:：十分公平， 可以先来后到，一定要排队</p>
</li>
<li>
<p>非公平锁:：十分不公平，可以插队（默认）</p>
</li>
</ul>
<h2 id="3reentrantlock-构造器">3、ReentrantLock 构造器</h2>
<ul>
<li>
<p>ReentrantLock 默认的构造方法是非公平锁（可以插队）。</p>
</li>
<li>
<p>如果在构造方法中传入 true 则构造公平锁（不可以插队，先来后到）。</p>
</li>
</ul>
<h2 id="4lock-锁实现步骤">4、Lock 锁实现步骤：</h2>
<ol>
<li>创建锁，new ReentrantLock()</li>
<li>加锁，lock.lock()</li>
<li>解锁，lock.unlock()</li>
<li>基本结构固定，中间的业务自己灵活修改</li>
</ol>
<h1 id="7synchronized-和-lock-锁的区别">7、synchronized 和 lock 锁的区别</h1>
<ol>
<li>
<blockquote>
<p>synchronized 是内置的 Java 关键字，Lock 是一个 Java 类</p>
</blockquote>
</li>
<li>
<blockquote>
<p>synchronized 无法判断获取锁的状态，Lock可以判断是否获取到了锁</p>
</blockquote>
</li>
<li>
<blockquote>
<p>synchronized 会自动释放锁，Lock 必须要手动释放锁！如果不释放锁，会产生死锁</p>
</blockquote>
</li>
<li>
<blockquote>
<p>synchronized 假设线程1（获得锁，然后发生阻塞），线程2（一直等待）； Lock 锁就不一定会等待下去，可使用 tryLock 尝试获取锁</p>
</blockquote>
</li>
<li>
<blockquote>
<p>synchronized 可重入锁，不可以中断的，非公平的；Lock锁，可重入的，可以判断锁，是否公平（可自己设置）</p>
</blockquote>
</li>
<li>
<blockquote>
<p>synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>总体来说，synchronized 本来就是一个关键字，很多规则都是定死的，灵活性差；Lock 是一个类，灵活性高</p>
</blockquote>
<h1 id="8生产者和消费者问题通信问题">8、生产者和消费者问题（通信问题）</h1>
<h2 id="1synchronized-版本">1、Synchronized 版本</h2>
<p>解决线程之间的通信问题，比如线程操作一个公共的资源类</p>
<p>基本流程可以总结为：</p>
<ul>
<li>
<p>等待：判断是否需要等待</p>
</li>
<li>
<p>业务：执行相应的业务</p>
</li>
<li>
<p>通知：执行完业务通知其他线程</p>
</li>
</ul>
<pre><code class="language-Java">public class ConsumeAndProduct {
    public static void main(String[] args) {
        Data data = new Data();
        // 创建一个生产者
        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();
        // 创建一个消费者
        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();
    }
}
//这是一个缓冲类，生产和消费之间的仓库,公共资源类
class Data{
    // 这是仓库的资源，生产者生产资源，消费者消费资源
    private int num = 0;
    // +1，利用关键字加锁
    public synchronized void increment() throws InterruptedException {
        // 首先查看仓库中的资源(num)，如果资源不为0，就利用 wait 方法等待消费，释放锁
        if(num!=0){
            this.wait();
        }
        num++;
        System.out.println(Thread.currentThread().getName()+"=&gt;"+num);
        // 通知其他线程 +1 执行完毕
        this.notifyAll();
    }
    // -1
    public synchronized void decrement() throws InterruptedException {
        // 首先查看仓库中的资源(num)，如果资源为0，就利用 wait 方法等待生产，释放锁
        if(num==0){
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName()+"=&gt;"+num);
        // 通知其他线程 -1 执行完毕
        this.notifyAll();
    }
}
</code></pre>
<p>思考问题：如果存在ABCD4个线程是否安全？</p>
<ul>
<li>不安全，会有虚假唤醒</li>
</ul>
<p>查看 api 文档<br>
<img src="https://img-blog.csdnimg.cn/d86541515cf3455ab50769bf5fd78b97.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p>解决办法：if 判断改为 while，防止虚假唤醒</p>
<ul>
<li>
<p>因为 if 只会执行一次，执行完会接着向下执行 if() 外边的代码</p>
</li>
<li>
<p>而 while 不会，直到条件满足才会向下执行 while() 外边的代码</p>
</li>
</ul>
<p>修改代码为：</p>
<pre><code class="language-Java">    // ...
    // 使用 if 存在虚假唤醒
    while (num!=0){
        this.wait();
    }
    // ...
    while(num==0){
        this.wait();
    }
</code></pre>
<h2 id="2juc-版本"><strong>2、JUC 版本</strong></h2>
<p>锁、等待、唤醒 都进行了更换<br>
<img src="https://img-blog.csdnimg.cn/dd05cd76cd7e40e4b10eeac812743e25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p>改造之后，确实可以实现01切换，但是ABCD是无序的，不满足我们的要求，</p>
<p>Condition 的优势在于，精准的通知和唤醒线程！比如，指定通知下一个进行顺序。</p>
<p>重新举个例子，</p>
<p>三个线程 A执行完调用B，B执行完调用C，C执行完调用A，分别用不同的监视器，执行完业务后指定唤醒哪一个监视器，实现线程的顺序执行</p>
<p>锁是统一的，但监视器是分别指定的，分别唤醒，signal，之前使用的是 signalAll</p>
<pre><code class="language-Java">  private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();
    private int num = 1; // 1A 2B 3C
    public void printA(){
        lock.lock();
        try {
            while (num != 1){
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName() + " Im A ");
            num = 2;
            condition2.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void printB(){
        lock.lock();
        try {
            while (num != 2){
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName() + " Im B ");
            num = 3;
            condition3.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void printC(){
        lock.lock();
        try {
            while (num != 3) {
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName() + " Im C ");
            num = 1;
            condition1.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h1 id="9八个有关锁的问题">9、八个有关锁的问题</h1>
<p><strong>深入理解锁</strong></p>
<h3 id="关于锁的八个问题"><strong>关于锁的八个问题</strong></h3>
<h2 id="问题1两个同步方法先执行发短信还是打电话"><strong>问题1：两个同步方法，先执行发短信还是打电话？</strong></h2>
<p>经过测试，一直是先发短信</p>
<p><img src="https://img-blog.csdnimg.cn/f61626937ffa42a6b716db1992615546.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_18,color_FFFFFF,t_70,g_se,x_16" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rsXbJVS7-1650013582524)(https://pizximfzuc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzExNGI3OTliYmQ5MTk5ZmVjMjYzNzAxM2MwYmQwMGJfM3l3b1NKWndKYVA5cjRrVHc4SWdxektzOGQxSmZKeHVfVG9rZW46Ym94Y25nTkhuUVdVdllwVWhiYVZXS09Oak0xXzE2NTAwMTM0OTI6MTY1MDAxNzA5Ml9WNA)]" loading="lazy"></p>
<h2 id="问题2如果发短信延迟2秒谁先执行"><strong>问题2：如果发短信延迟2秒，谁先执行</strong></h2>
<p>结果依旧是先发短信，后打电话</p>
<p>分析：</p>
<ul>
<li>
<p>并不是由于发短信在前导致的</p>
</li>
<li>
<p>本案例中，方法前加synchronized，锁的其实该方法的调用者，也就是 phone 实例，两个方法共用同一个 phone 对象的锁，谁先拿到，谁先执行</p>
</li>
<li>
<p>在主线程中，先调用发短信，所以先执行，打电话等释放锁再执行</p>
</li>
</ul>
<h2 id="问题3-加上一个没有锁的普通方法谁先执行"><strong>问题3 加上一个没有锁的普通方法，谁先执行</strong></h2>
<p>观察发现，先执行了 hello</p>
<p>分析原因：</p>
<ul>
<li>hello 是一个普通方法，不受 synchronized 锁的影响，不用等待锁释放。</li>
</ul>
<h2 id="问题4两个对象一个调用发短信一个调用打电话谁先执行"><strong>问题4：两个对象，一个调用发短信，一个调用打电话，谁先执行</strong></h2>
<p>结论，先打电话，后发短信</p>
<p>分析原因：</p>
<ul>
<li>两个对象两把锁，互不影响，1拿到锁还需要等待3秒，2拿到对象立刻就能打电</li>
</ul>
<h2 id="问题5原来的两个同步方法变为静态同步方法一个对象调用谁先执行"><strong>问题5：原来的两个同步方法，变为静态同步方法，一个对象调用，谁先执行</strong></h2>
<p>结果，始终是先发短信，后打电话</p>
<p>分析原因：</p>
<p>静态方法前面加锁，锁的其实是这个方法所在的Class类对象（非静态那个是实例对象，注意区分）</p>
<p>Class类对象也是全局唯一，使用的是通一把锁，所以先发短信，后打电话</p>
<p>虽然和上面的实例对象都是对应了全局唯一的锁，但原理还是有所不同</p>
<p>主线程先执行了发短信，打电话就必须等锁释放再执行</p>
<h2 id="问题6创建两个实例调用两个静态同步方法谁先执行"><strong>问题6：创建两个实例，调用两个静态同步方法，谁先执行</strong></h2>
<p>结果，现发短信，后打电话</p>
<p>原因分析：</p>
<ul>
<li>虽然实例对象是两个，但是两个静态同步方法对应的锁是Class类对象的锁，还是全局唯一</li>
</ul>
<h2 id="问题7一个静态同步方法一个同步方法一个对象调用谁先执行"><strong>问题7：一个静态同步方法、一个同步方法、一个对象调用，谁先执行</strong></h2>
<p>结果：先打电话，后发短信</p>
<p>原因分析：</p>
<ul>
<li>
<p>静态同步方法和普通同步方法分别对应了不同的锁，互不干扰</p>
</li>
<li>
<p>发短信需要延迟3秒，所以打电话先执行了</p>
</li>
</ul>
<h2 id="问题8两个对象一个调用静态同步方法一个调用普通同步方法谁先执行"><strong>问题8：两个对象，一个调用静态同步方法，一个调用普通同步方法，谁先执行</strong></h2>
<p>结果，先打电话，后发短信</p>
<p>分析原因：</p>
<p>同问题7相同，两个方法对应了不同的锁，互不干扰</p>
<p>发短信还需要等待3秒，所以打电话先执行完了</p>
<h2 id="小结"><strong>小结</strong></h2>
<blockquote>
<p>无外乎两种锁，一个是new实例的锁，一个是Class对象的锁</p>
</blockquote>
<blockquote>
<p>实例的锁，与当前的实例唯一对应，Class对象的锁与这个类唯一对应</p>
</blockquote>
<blockquote>
<p>如果两个方法等同一个锁，必须一个先执行完，释放锁，另一个才可以执行</p>
</blockquote>
<blockquote>
<p>如果两个方法等不同的锁，互不影响，谁先谁后看具体情况</p>
</blockquote>
<blockquote>
<p>在主线程中，代码是顺序执行的，再结合锁的原理，综合判断线程执行的顺序</p>
</blockquote>
<h1 id="10集合类的安全问题">10、集合类的安全问题</h1>
<p>在 JUC 并发编程情况下，适用于单线程的集合类将出现并发问题</p>
<h2 id="1list-不安全"><strong>1、List 不安全</strong></h2>
<p>运行出现并发修改异常，</p>
<pre><code>java.util.ConcurrentModificationException
</code></pre>
<p>解决方案：</p>
<blockquote>
<p><strong>解决方案1：</strong></p>
</blockquote>
<ul>
<li>
<blockquote>
<p>ArrayList 换成 Vector，Vector 方法里加了锁</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Vector出现比较早，由于锁导致方法执行效率太低，不推荐使用</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>解决方案2：</strong></p>
</blockquote>
<ul>
<li>
<blockquote>
<p>使用 Collection 静态方法，返回一个带锁的 List 实例</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>List<string> list = Collections.synchronizedList(new ArrayList&lt;&gt;());</string></p>
</blockquote>
<blockquote>
<p><strong>解决方案3：</strong></p>
</blockquote>
<ul>
<li>
<blockquote>
<p>使用 JUC 提供的适合并发使用的 CopyOnWriteArrayList</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>List<string> list = new CopyOnWriteArrayList&lt;&gt;();</string></p>
</blockquote>
<p>分析：</p>
<p>CopyOnWrite 表示写入时复制，简称COW，计算机程序设计领域的一种优化策略</p>
<p>多线程调用list时，读取时没有问题，写入的时候会复制一份，避免在写入时被覆盖</p>
<p>这也是一种读写分离的思想</p>
<p>CopyOnWriteArrayList 比 Vector 强在哪里？前者是写入、复制，且使用 lock 锁，效率比 Vector 的synchronized 锁要高很多</p>
<h2 id="2set-不安全"><strong>2、Set 不安全</strong></h2>
<p>Set 和 List 同理可得：多线程情况下，普通的 Set 集合是线程不安全的</p>
<ul>
<li>
<blockquote>
<p><strong>使用 Collection 工具类的 synchronized 包装的 Set 类</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Set<string> set = Collections.synchronizedSet(new HashSet&lt;&gt;());</string></p>
</blockquote>
<ul>
<li>
<blockquote>
<p><strong>使用 JUC 提供的 CopyOnWriteArraySet 写入复制</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Set<string> set = new CopyOnWriteArraySet&lt;&gt;();</string></p>
</blockquote>
<p>思考，HashSet 底层到底是什么？</p>
<ul>
<li>hashSet底层就是一个HashMap；hashSet只使用了hashMap的key</li>
</ul>
<h1 id="11callable简单">11、Callable（简单）</h1>
<blockquote>
<p><strong>得到的信息</strong>：</p>
</blockquote>
<blockquote>
<p>可以有返回值</p>
</blockquote>
<blockquote>
<p>可以抛出异常</p>
</blockquote>
<blockquote>
<p>方法不同，run() =&gt; call()</p>
</blockquote>
<blockquote>
<p><strong>使用时注意</strong></p>
</blockquote>
<ul>
<li>
<blockquote>
<p>Callable 的泛型也是 call 方法的返回值类型</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Callable 的实现类无法直接放在 Thread 中，还需要先放在 -</p>
</blockquote>
</li>
<li>
<blockquote>
<p>FutureTask 中，再放在 Thread 中FutureTask 就相当于适配类，起到牵线的作用</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>运行结果会产生缓存，目的是为了提高效率</p>
</blockquote>
</li>
<li>
<blockquote>
<p>get方法可能会产生阻塞，所以放在了最后</p>
</blockquote>
</li>
</ul>
<h1 id="12juc-常用辅助类">12、JUC 常用辅助类</h1>
<h2 id="1countdownlatch">1、CountDownLatch</h2>
<p>减法计数器</p>
<blockquote>
<p>原理:</p>
</blockquote>
<blockquote>
<p>countDownLatch.countDown(); //数量减1</p>
</blockquote>
<p>countDownLatch.await();// 等待计数器归零,然后再向下执行</p>
<p>每次有线程调用countDown()数量-1，假设计数器变为0，countDownLatch.await();就会被唤醒，继续执行</p>
<h2 id="2cyclickbarrier">2、CyclickBarrier</h2>
<p>加法计数器，与 CountDownLatch 正好相反</p>
<p>相当于设定一个目标，线程数达到目标值之后才会执行</p>
<h2 id="3semaphore">3、Semaphore</h2>
<p>计数信号量，比如说，有6辆车，3个停车位，汽车需要轮流等待车位</p>
<p>常用在需要限流的场景中，</p>
<blockquote>
<p>原理：</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>*semaphore.acquire() 获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！</p>
</blockquote>
</li>
<li>
<blockquote>
<p>*semaphore.release() 释放，会将当前的信号量释放+1，然后唤醒等待的线程！</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>用途：</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>*多个共享资源互斥的使用！</p>
</blockquote>
</li>
<li>
<blockquote>
<p>*并发限流，控制最大的线程数！</p>
</blockquote>
</li>
</ul>
<h1 id="13readwritelock-读写锁">13、ReadWriteLock 读写锁</h1>
<p><img src="https://img-blog.csdnimg.cn/b2f42dbe609e4f0784722c2548d7cc32.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" loading="lazy"></p>
<p><code>ReadWriteLock</code>，这是一个更加细粒度的锁</p>
<pre><code class="language-Java">// 自定义缓存
class MyCache{
    private volatile Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
    private ReadWriteLock readWriteLock= new ReentrantReadWriteLock();
    // 存，写,写入的时候只希望只有一个线程在写
    public void write(String key, String value) {
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "线程开始写入");
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "线程开始写入ok");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }
    // 取，读,所有线程都可以读
    public void read(String key) {
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "线程开始读取");
            map.get(key);
            System.out.println(Thread.currentThread().getName() + "线程读取ok");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }
}
</code></pre>
<p>小结：</p>
<ul>
<li>读-读 可以共存</li>
<li>读-写 不能共存</li>
<li>写-写 不能共存</li>
</ul>
<p>也可以这样称呼，含义都是一样，名字不同而已</p>
<ul>
<li>独占锁（写锁）一次只能由一个线程占有</li>
<li>享锁（读锁）一次可以有多个线程占有</li>
</ul>
<h1 id="14阻塞队列">14、阻塞队列</h1>
<h2 id="1blockqueue">1、Blockqueue</h2>
<p>阻塞队列 BlockQueue 是Collection 的一个子类</p>
<p>应用场景：多线程并发处理、线程池</p>
<p>BlockingQueue 有四组 API</p>
<p>方式 抛出异常 不会抛出异常,有返回值 阻塞等待 超时等待</p>
<p>添加操作 add() offer() 供应 put() offer(obj,int,timeunit.status)可设置时间</p>
<p>移除操作 remove() poll() 获得 take() poll(int,timeunit.status)可设置时间</p>
<p>判断队列首部 element() peek() 偷看,偷窥 SynchronizedQueue 同步队列</p>
<p>同步队列没有容量，进去一个元素，必须等待取出来之后，才能再往里面放一个元素</p>
<h2 id="2synchronizedqueue">2、SynchronizedQueue</h2>
<ul>
<li>SynchronizedQueue使用 put 方法和 take 方法</li>
<li>Synchronized 和 其他的 BlockingQueue 不一样 它不存储元素；</li>
<li>put了一个元素，就必须从里面先 take 出来，否则不能再 put 进去值！</li>
<li>并且 SynchronousQueue 的 take 是使用了 lock 锁保证线程安全的。</li>
</ul>
<h1 id="15线程池重点">15、线程池（重点）</h1>
<p><strong>池化技术</strong></p>
<p><strong>线程池重点</strong>：三大方式、七大参数、四种拒绝策略</p>
<p>程序的运行的本质：占用系统的资源 ! 优化CPU资源的使用 ===&gt;池化技术（线程池、连接池、内存池、对象池…）</p>
<p><strong>池化技术</strong>：实现准备好一些资源，有人要用，就来我这里拿，用完之后还给我</p>
<p><strong>线程池的好处:</strong></p>
<ul>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>方便管理</li>
</ul>
<p><strong>如何优化：</strong></p>
<ul>
<li>线程复用,可以控制最大并发数,管理线程</li>
</ul>
<h2 id="1线程池三大方法">1、线程池：三大方法</h2>
<p>查看阿里巴巴开发手册<br>
<img src="https://img-blog.csdnimg.cn/fa484988cd944e36af6e496c8af230f5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<ol>
<li>ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程</li>
<li>ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小</li>
<li>ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的（不会出现OOM）</li>
</ol>
<p>之前我们所学知识，直接创建线程，现在我们通过线程池来创建线程，使用池化技术</p>
<pre><code class="language-Java">&gt;  ExecutorService service = Executors.newCachedThreadPool();//可伸缩的，遇强则强，遇弱则弱
&gt;         try {
&gt;             for (int i = 0; i &lt; 10; i++) {
&gt;                 service.execute(() -&gt; {
&gt;                     System.out.println(Thread.currentThread().getName() + "ok");
&gt;                 });
&gt;             }
&gt;             //线程池用完要关闭线程池
&gt;         } finally {
&gt;             service.shutdown();
&gt;         }
</code></pre>
<h2 id="2线程池七大参数">2、线程池：七大参数</h2>
<pre><code class="language-Java">public ThreadPoolExecutor(int corePoolSize,//核心线程数 也就是一直工作的线程数量
                          int maximumPoolSize,//最大线程数，如果核心心线程数使用完
                          long keepAliveTime,//非核心线程的存活时间
                          TimeUnit unit,//非核心线程的存活时间单位
                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列
                          ThreadFactory threadFactory,//线程工厂
                          RejectedExecutionHandler handler) //拒绝策略
</code></pre>
<p><strong>提交优先级</strong></p>
<p>execute()提交方法中源码中的几个if里面都会调用执行方法addWorker(Rannale firstTask,boolean core )<br>
<img src="https://img-blog.csdnimg.cn/380f9666baea4f6ca8922dbd4cbc4267.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6KX6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>执行优先级</strong><br>
<img src="https://img-blog.csdnimg.cn/2d62d7fb3cfb452aa18fce67073eb73f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/e0697e1da0f84f408a04402830e2627a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-X6aOO6ZuF6Z-1,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p>执行优先级：</p>
<blockquote>
<p>addWorker(Rannale firstTask,boolean core )</p>
</blockquote>
<p>submit（）与execute()区别</p>
<blockquote>
<p>1、submit（）有返回值，execute()没有返回值</p>
</blockquote>
<blockquote>
<p>2、submit()方法里面调用了execute()方法</p>
</blockquote>
<h3 id="3四大拒绝策瑜">3、四大拒绝策瑜：</h3>
<p><img src="https://img-blog.csdnimg.cn/24257ace9201442597e92a9efc58c874.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="16为什么要使用线程池">16、为什么要使用线程池？</h1>
<p>为了减少创建和销毁线程的次数，让每个线程可以多次使用,可根据系统情况<strong>调整执行</strong>的线程数量，防止消耗过多内存,所以我们可以使用线程池.</p>
<h1 id="17线程池线程复用的原理是什么">17、线程池线程复用的原理是什么？</h1>
<p>首先线程池内的线程都被包装成了一个个的java.util.concurrent.ThreadPoolExecutor.Worker,然后这个worker会马不停蹄的执行任务,执行完任务之后就会在while循环中去取任务,取到任务就继续执行,取不到任务就跳出while循环(这个时候worker就不能再执行任务了)执行 processWorkerExit方法,这个方法呢就是做清场处理,将当前woker线程从线程池中移除,并且判断是否是异常的进入processWorkerExit方法,如果是非异常情况,就对当前线程池状态(RUNNING,shutdown)和当前工作线程数和当前任务数做判断,是否要加入一个新的线程去完成最后的任务(防止没有线程去做剩下的任务).</p>
<p>那么什么时候会退出while循环呢?取不到任务的时候(getTask() == null)</p>
<pre><code class="language-TypeScript">/java/util/concurrent/ThreadPoolExecutor.java:1127
final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {...执行任务...}
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }




private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            //(rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()) || rs &gt;=STOP
            //若线程池状态是SHUTDOWN 并且 任务队列为空,意味着已经不需要工作线程执行任务了,线程池即将关闭
            //若线程池的状态是 STOP TIDYING TERMINATED,则意味着线程池已经停止处理任何任务了,不在需要线程
            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
                    //把此工作线程从线程池中删除
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            //allowCoreThreadTimeOut:当没有任务的时候,核心线程数也会被剔除,默认参数是false,官方推荐在创建线程池并且还未使用的时候,设置此值
            //如果当前工作线程数 大于 核心线程数,timed为true
            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
                        
            //(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)):当工作线程超过最大线程数,或者 允许超时并且超时过一次了
            //(wc &gt; 1 || workQueue.isEmpty()):工作线程数至少为1个 或者 没有任务了
            //总的来说判断当前工作线程还有没有必要等着拿任务去执行
            //wc &gt; maximumPoolSize &amp;&amp; wc&gt;1 : 就是判断当前工作线程是否超过最大值
            //或者 wc &gt; maximumPoolSize &amp;&amp; workQueue.isEmpty():工作线程超过最大,基本上不会走到这,
            //                如果走到这,则意味着wc=1 ,只有1个工作线程了,如果此时任务队列是空的,则把最后的线程删除
            //或者(timed &amp;&amp; timedOut) &amp;&amp; wc&gt;1:如果允许超时并且超时过一次,并且至少有1个线程,则删除线程
            //或者 (timed &amp;&amp; timedOut) &amp;&amp; workQueue.isEmpty():如果允许超时并且超时过一次,并且此时工作                                        队列为空，那么妥妥可以把最后一个线程（因为上面的wc&gt;1不满足，则可以得出来wc=1）删除
            if ((wc &gt; maximumPoolSize  || (timed &amp;&amp; timedOut))
                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                        //如果减去工作线程数成功,则返回null出去,也就是说 让工作线程停止while轮训,进行收尾
                    return null;
                continue;
            }

            try {
                    //判断是否要阻塞获取任务
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
</code></pre>
<h1 id="18aqs的理解">18、AQS的理解</h1>
<h4 id="1reentrantlock和aqs的关系">1、ReentrantLock和AQS的关系</h4>
<p>java并发包下的很多API都是基于AQS来实现加锁和释放等功能，AQS是并java发包的基础类。</p>
<p>举个列子，ReentrantLock、ReentrantReadWr</p>
<p>iteLock底层都是基于AQS来实现的。ReentrantLock内部包含已个AQS对象。</p>
<p>AQS的全称是AbstractQueueSynchonizer，抽象队列同步锁。</p>
<h4 id="2reentrantlock加锁和释放锁的底层原理">2、ReentrantLock加锁和释放锁的底层原理</h4>
<blockquote>
<p>如果现在有一个线程过来尝试用ReentrantLock的lock()方法进行加锁，会发生什么？</p>
</blockquote>
<blockquote>
<p>很简单，这个AQS对象内部有一个核心的变量state，是int类型的，代表加锁的状态。初始情况下为0.</p>
</blockquote>
<blockquote>
<p>另外AQS内部还有一个关键变量，用来记录加锁线程是哪个线程，初始化状态下，这个线程是null。</p>
</blockquote>
<p>[MISSING IMAGE: image-20220324164210432, image-20220324164210432 ]</p>
<blockquote>
<p>接着线程1跑过来会调用ReentrantLock的lock()方法尝试加锁，这个加锁的过程，是直接用CAS操作将state值进行0-&gt;1的。如果之间前没有人加过锁，那么state为0，此时线程1加锁成功</p>
</blockquote>
<blockquote>
<p>一旦线程加锁成功后，就可以设置当前线程就是自己。</p>
</blockquote>
<blockquote>
<p>下图就是线程1的加锁过程</p>
</blockquote>
<blockquote>
<p>其实到这就知道了AQS就是并发包里的一个核心组件，里面有state变量，加锁 线程变量等核心东西，维护了加锁状态。你会发现ReentrantLock就是一个外面的API，内部的核心锁机制都是依赖AQS组件的</p>
</blockquote>
<blockquote>
<p>这个ReentrantLock之所以以Reentrant开头，意思是它可以可重入锁。</p>
</blockquote>
<blockquote>
<p>可重入锁的意思是，就是你可以对ReentrantLock对象多次执行lock()加锁和unlock()释放锁，也就是可以对一个锁加多次，叫做可重入加锁</p>
</blockquote>
<blockquote>
<p>明白这个后看这个state变量，其实每次线程1可重入加锁一次，那么他会判断当前线程就是自己，那么他自己就可以冲重入多次加锁。每次都state+1，别的没有变化。</p>
</blockquote>
<blockquote>
<p>线程1加锁完成后，那么线程2跑来加锁会发生什么呢？</p>
</blockquote>
<blockquote>
<p>我们看看互斥锁怎么实现的，线程2跑来发现state不是0，所以CAS重0-&gt;1就失败，因为不为0说明被加锁锁了，那么就会去看当前加锁线程是否是自己，不是的话自己就加锁失败。</p>
</blockquote>
<blockquote>
<p>看图示意：</p>
</blockquote>
<p>[MISSING IMAGE: image-20220324170008447, image-20220324170008447 ]</p>
<blockquote>
<p>接着，线程2就会将自己放入到AQS的一个等待队列，因为自己尝试加锁失败了，此时就要将自己放入队列中等待，等待线程1释放锁之后，自己就可以重新尝试加锁了。</p>
</blockquote>
<blockquote>
<p>能够看到，AQS是如此的核心，AQS内部还有一个等待u队列，专门放哪些加锁失败的线程。</p>
</blockquote>
<p>[MISSING IMAGE: image-20220324170416331, image-20220324170416331 ]</p>
<blockquote>
<p>接着，线程1在执行完自己的业务后，就会释放锁！他释放锁的过程很简单，就是将AQS内部的state变量值递减到，将“加锁线程”也是设置为null，彻底释放锁了。</p>
</blockquote>
<blockquote>
<p>接下来，会从等待队列中唤醒对头的线程2，线程2重新尝试加锁。还是用CAS将state变为1，当前线程为自己线程，同时线程2自己就可以出队了。</p>
</blockquote>
<h1 id="19线程创建的三种方式">19、线程创建的三种方式</h1>
<ul>
<li>
<blockquote>
<p>1、Thread类</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>是Java中表示线程的类，里面包含了一个线程运行过程中方法run()方法</p>
</blockquote>
<blockquote>
<p>使用Thread类创建并启动线程的步骤：</p>
</blockquote>
<blockquote>
<p>1.写一个类，继承Thread类</p>
</blockquote>
<blockquote>
<p>2.覆盖Thread类中的run()方法</p>
</blockquote>
<blockquote>
<p>3.创建线程的实例对象</p>
</blockquote>
<blockquote>
<p>4.调用线程的实例对象的start()方法去启动线程</p>
</blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<p>1.启动线程调用start()方法</p>
</blockquote>
<blockquote>
<p>2.启动线程之后会自动调用run()方法</p>
</blockquote>
<blockquote>
<p>3.需要线程完成某件事情，将对应的代码添加到run()方法中即可</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>2、实现Runnale接口（推荐使用）</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>步骤：</p>
</blockquote>
<ol>
<li>
<blockquote>
<p>写一个类实现Runnable接口</p>
</blockquote>
</li>
<li>
<blockquote>
<p>实现Runnable接口中的run()</p>
</blockquote>
</li>
<li>
<blockquote>
<p>创建Thread类创建对象，并将第三步创建的对象作为参数传递到构造方法中</p>
</blockquote>
</li>
<li>
<blockquote>
<p>调用Thread创建对象的start（）方法，启动线程</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>采用匿名内部类方式创建线程（固定格式）</strong></p>
</blockquote>
<pre><code class="language-Java">public static void main(String[] args) {
    Thread th = new Thread() {
        public void run() {
        System.out.println("匿名内部类的run方法");
        };
     };
    th.start();
}
</code></pre>
<ul>
<li>
<blockquote>
<p>3、实现Callable接口，并与future</p>
</blockquote>
</li>
<li>
<blockquote>
<p>4、线程池结合使用</p>
</blockquote>
</li>
</ul>
<h1 id="20为什么启动start就调用run方法">20、为什么启动start(),就调用run方法</h1>
<p>关注源码可以发现，在start（）方法中，默认调用了一个JNI方法，这个方法是java平台用于和本地C代码进行相互操作的API</p>
<h1 id="21线程的生命周期">21、线程的生命周期</h1>
<p>线程的生命周期就是线程的状态</p>
<ul>
<li>1新建状态 new</li>
</ul>
<p>当使用new关键字创建线程实例后，该线程就属于新建状态，但是不会执行</p>
<ul>
<li>2、就绪状态Runnable</li>
</ul>
<p>当调用start()方法时，该线程处于就绪状态，表示可以执行，但是不一定会立即执行，而是等待cpu</p>
<p>分配时间片进行处理</p>
<ul>
<li>3、运行状态（Running）</li>
</ul>
<p>当为该线程分配到时间片后，执行该方法的run方法，就处于运行状态</p>
<ul>
<li>4、暂停状态（包括休眠、等待、阻塞等）（Block）</li>
</ul>
<p>当线程调用sleep（）方法，主动放弃CPU资源，或者线程吊用阻塞IO方法时，比如控制台的Scannner输入方法</p>
<ul>
<li>死亡状态（dead）</li>
</ul>
<p>当线程的run（）方法执行完成之后就处于死亡状态</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>1.当线程创建时，并不会立即执行，需要调用start方法，使其处于就绪状态</p>
</blockquote>
<blockquote>
<p>2.线程处于就绪状态时，也不会立即执行线程，需要等待CPU分配时间</p>
</blockquote>
<blockquote>
<p>3.当线程阻塞时，会让出占有的CPU，当阻塞结束时，线程会进入就绪状态，重新等待CPU，而不是直接进入到运行状态</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>Thread.yield()：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>让出当前CPU时间片，该线程会从运行状态进入到就绪状态，此时继续与其他线程抢占CPU</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>Thread.sleep(time)：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>让线程休眠time毫秒，该线程会从运行状态进入到阻塞状态，不会与其他线程抢占CPU。当time毫秒过后，该线程会从阻塞状态进入到就绪状态，重新与其他线程抢占CPU</p>
</blockquote>
<p>异步的效率会比同步的高，但是异步存在数据安全问题</p>
<p>多线程并发执行，也就是线程异步处理，并发执行存在线程安全问题</p>
<h1 id="21线程安全">21、线程安全：</h1>
<p>在实际开发中，使用多线程程序的情况很多，如银行排号系统、火车站售票系统等。这种多线程的程序通常会发生问题，以火车站售票系统为例，在代码中判断当前票数是否大于0,如果大于0则执行将该票出售给乘客的功能，但当两个线程同时访问这段代码时(假如这时只剩下一张票)，第一个线程将票售出，与此同时第二个线程也已经执行完成判断 是否有票的操作， 并得出结论票数大于0,于是它也执行售出操作，这样就会产生负数。所以在编写多线程程序时，应该考虑到钱程安全问题。实质上线程安全问题来源于两个线程同时存取单一对象的数据。</p>
<h4 id="线程安全解决问题方案">线程安全解决问题方案：</h4>
<h2 id="1互斥阻塞同步也就是加锁sychronized和reenrtrantlock加锁优缺点">1、互斥阻塞同步：也就是加锁sychronized和ReenrtrantLock,加锁优缺点？</h2>
<h1 id="22线程同步机制">22、线程同步机制</h1>
<p>为了避免多线程的安全问题，需要在公共访问的内容上加锁，加锁之后，当一个线程执行该内容时，其他线程无法执行该内容，只有当该线程将此部分内容执行完了之后，其他线程才可以执行。</p>
<ul>
<li>1.找到多线程公共执行的内容</li>
<li>2.在此内容上合适的位置加上锁</li>
</ul>
<p><strong>锁：</strong></p>
<p><strong>1、****synchronized可以加在方法上，也可以加在代码块中</strong></p>
<p><strong>加在方法上，在返回值前面加synchronized既可，</strong></p>
<pre><code class="language-Java">比如：public synchronized void run() {}表示给run方法整体加上了锁。
加在代码块上：
synchronized(this) {
//需要同步执行的代码
}
</code></pre>
<p>注意：加锁之后，被加锁的代码就变成了同步，会影响效率，所以应该尽量减小加锁的范围</p>
<p>2、也可以用RantantLock</p>
<h1 id="23run方法和sart方法有什么区别">23、run()方法和sart（）方法有什么区别</h1>
<p>run()方法是线程的执行体，他的方法代表线程需要完成的任务，而start（）方法用来启动线程。</p>
<h1 id="24线程是否可以被重复启动">24、线程是否可以被重复启动</h1>
<h1 id="25volatile">25、volatile</h1>
<h1 id="26java多线程之间的三种通信方式">26、java多线程之间的三种通信方式</h1>
<h2 id="1synchronized来保证线程安全">1、synchronized来保证线程安全</h2>
<p>如果线程之间是通过synchronized来保证线程安全，则可以利用wait（）、notify（）、notifyAll（）来实现通信</p>
<h2 id="2通过lock">2、通过Lock（）</h2>
<p>如果线程之间是通过Lock（）来保证线程安全的，则可以利用await()、signal()、signalAll()来说实现线程通信</p>
<p>这三个方法都是Condition接口中的方法。</p>
<h2 id="3blockingqueue">3、BlockingQueue</h2>
<p>jdk1.5中提供了BlockingQueue接口，虽然四Queue的子接口，但是主要用途并不是作为容器，而是作为线程的通信工具。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入一个元素，如果该队列已满，则该线程阻塞；</p>
<h1 id="27说一说synchronized的底层实现原理">27、说一说synchronized的底层实现原理</h1>
<blockquote>
<p>一、synchronized作用在代码块时，它的底层是通过monitorenter、monitorexit指令来实现的。</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>*monitorenter：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>每个对象都是一个监视器锁（monitor），当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
</blockquote>
<blockquote>
<p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>*monitorexit：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>执行monitorexit的线程必须是objectref所对应的monitor持有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</p>
</blockquote>
<blockquote>
<p>monitorexit指令出现了两次，第1次为同步正常退出释放锁，第2次为发生异步退出释放锁。</p>
</blockquote>
<blockquote>
<p>二、方法的同步并没有通过 monitorenter 和 monitorexit 指令来完成，不过相对于普通方法，其常量池中多了 ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的：</p>
</blockquote>
<blockquote>
<p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
</blockquote>
<blockquote>
<p>三、总结</p>
</blockquote>
<blockquote>
<p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响</p>
</blockquote>
<h1 id="28cas">28、CAS</h1>
<h2 id="1概念">1、概念</h2>
<h2 id="2cas可能产生aba问题">2、CAS可能产生ABA问题：</h2>
<p>　　　ABA解决问题：加一个版本号</p>
<p>　　　版本号：数值型或者布尔型</p>
<h1 id="29锁升级初步">29、锁升级初步</h1>
<ul>
<li>new-&gt;偏向锁-&gt;轻量级锁(无锁、自旋锁、自适应自旋3)-&gt;重量级锁</li>
</ul>
<h2 id="1偏向锁">1、偏向锁：</h2>
<blockquote>
<p>在锁对象的对象头中记录⼀下当前获取到该锁的线程ID，该线程下次如果⼜来获取该锁就</p>
</blockquote>
<h2 id="2轻量级锁">2、轻量级锁</h2>
<blockquote>
<p>由偏向锁升级⽽来，当⼀个线程获取到锁后，此时这把锁是偏向锁，此时如果有第⼆个 线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻 量级锁底层是通过⾃旋来实现的，并不会阻塞线程</p>
</blockquote>
<h2 id="3锁重入锁">3、锁重入锁</h2>
<blockquote>
<p>sychnronized必须记录重入次数，因为要解锁必须对应次数</p>
</blockquote>
<blockquote>
<p>偏向锁 自旋锁 -&gt;线程栈-&gt;LR+1</p>
</blockquote>
<h2 id="4自旋锁什么时候升级为重量级锁">4、自旋锁什么时候升级为重量级锁</h2>
<blockquote>
<p>竞争加剧：有线程超过10次，或者自旋锁线程数超过CPU核数的一半，1.6以后加入自适应自旋，JVM自己控</p>
</blockquote>
<h2 id="5为什么有自旋锁还需要重量级锁">5、为什么有自旋锁还需要重量级锁</h2>
<blockquote>
<p>自旋是消耗CPU资源的，如果时间过长或者自旋线程数多，CPU会被大量消耗</p>
</blockquote>
<blockquote>
<p>重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源</p>
</blockquote>
<h2 id="6偏向锁是否一定比自旋锁效率高">6、偏向锁是否一定比自旋锁效率高</h2>
<blockquote>
<p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁</p>
</blockquote>
<blockquote>
<p>JVM启动过程，会有很多线程竞争（明确），所以默认情况下启动是不会启动偏向锁，过一会时间再打开</p>
</blockquote>
<h1 id="30threadlocal机制">30、ThreadLocal机制</h1>
<blockquote>
<p><strong>对于ThreadLocal而言，常用的方法，就是get/set/initialValue方法。</strong></p>
</blockquote>
<blockquote>
<p>ThreadLocal提供一个线程（Thread）局部变量，访问到某个变量的每一个线程都拥有自己的局部变量。说白了，ThreadLocal就是想在多线程环境下去保证成员变量的安全。</p>
</blockquote>
<blockquote>
<p>你会看到，set需要首先获得当前线程对象Thread；</p>
</blockquote>
<blockquote>
<p>然后取出当前线程对象的成员变量ThreadLocalMap；</p>
</blockquote>
<blockquote>
<p>如果ThreadLocalMap存在，那么进行KEY/VALUE设置，KEY就是ThreadLocal；</p>
</blockquote>
<blockquote>
<p>如果ThreadLocalMap没有，那么创建一个；</p>
</blockquote>
<blockquote>
<p>说白了，当前线程中存在一个Map变量，KEY是ThreadLocal，VALUE是你设置的值。</p>
</blockquote>
<h1 id="31threadlocal机制的内存泄露">31、ThreadLocal机制的内存泄露</h1>
<blockquote>
<p><strong>首先来说，如果把ThreadLocal置为null，那么意味着Heap中的ThreadLocal实例不在有强引用指向，只有弱引用存在，因此GC是可以回收这部分空间的，也就是key是可以回收的。但是value却存在一条从Current Thread过来的强引用链。因此只有当Current Thread销毁时，value才能得到释放。</strong></p>
</blockquote>
<blockquote>
<p><strong>因此，只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间内不会被回收的，就发生了我们认为的内存泄露。最要命的是线程对象不被回收的情况，比如使用线程池的时候，线程结束是不会销毁的，再次使用的，就可能出现内存泄露。</strong></p>
</blockquote>
<blockquote>
<p><strong>那么如何有效的避免呢？</strong></p>
</blockquote>
<blockquote>
<p><strong>事实上，在ThreadLocalMap中的set/getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。我们也可以通过调用ThreadLocal的remove方法进行释放！</strong></p>
</blockquote>
<h5 id="留言">留言：</h5>
<p>这是本人今年春招找实习工作准备总结，记录在此，如有需要的老铁可以看看，如有问题可以留言指导</p>

</div>
<div class="clear"></div>
<div id="blog_post_info_block" role="contentinfo">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2022-04-16 21:50</span>&nbsp;
<a href="https://www.cnblogs.com/zbqblogs/">诗风雅韵</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=16154384" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(16154384);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '16154384', targetLink: 'https://www.cnblogs.com/zbqblogs/p/16154384.html', title: '多线程JUC并发篇常见面试详解' })">举报</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>

<script>
    var cb_entryId = 16154384, cb_entryCreatedDate = '2022-04-16 21:50', cb_postType = 1, cb_postTitle = '多线程JUC并发篇常见面试详解';
    var allowComments = true, cb_blogId = 744735, cb_blogApp = 'zbqblogs', cb_blogUserGuid = 'f0654729-7e5c-4194-b895-08d91391c1ab';
    mermaidRender.render()
    markdown_highlight()
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
    updatePostStats(
            [cb_entryId],
            function(id, count) { $("#post_view_count").text(count) },
            function(id, count) { $("#post_comment_count").text(count) })
</script>
<a id="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="cnblogs_ch"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
            <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
        <div id="cnblogs_c2" class="under-post-card">
            <a href="https://developer.huawei.com/consumer/cn/forum/topic/0202851788421280176?fid=23&amp;ha_source=bokeyuan&amp;ha_source=HeZuo30&amp;ha_sourceId=89000081" rel="nofollow" target="_blank" onclick="countCreativeClicks('C2-华为-codelabs')">
                <img src="https://img2022.cnblogs.com/blog/35695/202204/35695-20220413123003334-931328747.jpg" alt="" onload="countCreativeImpressions('C2-华为-codelabs')" />
            </a>
        </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
        var commentManager = new blogCommentManager();
        commentManager.renderComments(0);
        fixPostBody();

                        window.tocManager.displayDisableTocTips = false;
                        window.tocManager.generateToc();
            setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverT2();
        deliverC1C2();
        loadNewsAndKb();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2022 诗风雅韵
<br /><span id="poweredby">Powered by .NET 6 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    

    <input type="hidden" id="antiforgery_token" value="CfDJ8AuMt_3FvyxIgNOR82PHE4kckFDwauBlW4ElWYCoB1qLLQbyeqEv8hT7H6_9pesmOL__f-toFY_gQU-D1WO_UyoJIlt4RRijvWB5FMBxF1xPfCy5_-DzeDTVjlA701eHnd5d8mIrbkkixpA0gsZcHks" />
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-476124-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        var kv = getGACustom();
        if (kv) {
            gtag('set', kv);
        }
        gtag('config', 'UA-476124-1');
    </script>
<script defer src="https://hm.baidu.com/hm.js?866c9be12d4a814454792b1fd0fed295"></script>
</body>
</html>